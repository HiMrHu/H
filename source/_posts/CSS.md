---
title: CSS
date: 2020-04-23 14:27:53
tags: CSS
---

CSS (Cascading Style Sheets)

<!-- more -->

# CSS 基础

## 层叠 优先级和 继承

### C (Cascading) 层叠

CSS 的本质就是声明规则, 在各种条件下,达到预期的效果. CSS 开发最总要的一点就是以可预测的方式书写规则.

层叠规则发生冲突之后,层叠会根据三种条件解决冲突:

1. 样式表来源(用户样式高于浏览器默认样式)
2. 选择器优先级(ID 选择器高于 class 选择器)
3. 源码顺序(后面的会覆盖前面的样式)
   之外还有一个例外就是 `!important`

#### 理解优先级

如果无法用来源解决冲突声明,浏览器会尝试检查他们的优先级.

浏览器将优先级分为两种: HTML 的行内样式和选择器样式.

1. 行内样式
   如果要覆盖行内样式就需要为声明添加`!important`,但是如果行内样式你也添加了`!important`,那么他就无法被覆盖了.

2. 选择器优先级
   优先级的第二部分是由选择器决定的, 例如,有两个类名的选择器比只有一个类名的选择器优先级更高.
   不用的选择器有不同的优先级. 优先级的规则如下

- 如果选择器的 ID 数量多,那么他会胜出
- 如果 ID 数量一致, 那么拥有最多类的选择器会胜出
- 如果以上两次比较都一致, 那么拥有最多标签名的选择器胜出

3. 优先级标记

常用的标识优先级的方式是使用数值方式来进行标记, 通常使用逗号隔开每个数.优先级最高的 ID 列为第一位, 紧接着是 class 最后是标签.

各种选择器和对应的优先级

| 选择器                      | ID  | 类  | 标签 | 标记  |
| --------------------------- | --- | --- | ---- | ----- |
| html body header h1         | 0   | 0   | 4    | 0,0,4 |
| body header .page-header h1 | 0   | 1   | 3    | 0,1,3 |
| .page-header .title         | 0   | 2   | 0    | 0,2,0 |
| #page-title                 | 1   | 0   | 0    | 1,0,0 |

通过比较数值就可以得出那个选择器优先级更高.

4. 优先级的思考

使用优先级来解决覆盖与被覆盖的问题.

#### 源码顺序

如果两个声明的来源和优先级相同,其中一个声明在样式表中出现的比较晚, 或者位于页面交完引入的样式表中,则该声明胜出.

浏览器遵循三个步骤,即来源 优先级 源码顺序, 来解析网页上每个元素的每个属性,如果一个声明在层叠中"胜出", 他就被称作一个层叠值, 元素的每个属性最多只有一个层叠值.

#### 两条经验法则

1. 尽量不要再唉选择器中使用 ID ,因为哪怕只有一个 ID 那么他的优先级也会大幅度提升.
2. 也尽量不要使用!important, 它比 ID 更难覆盖,一旦使用了它如果想覆盖它就可能需要再加上一个 !important .

并且在分发 JavaScript 包到 npm 的时候, 也强烈建议不要使用 行内样式 因为如果使用者想要覆盖行内样式那么就需要给每一个属性添加 !important, 而正确的做法是在包里包含一个样式表, 单独引入,这样如果有修改的需要,那么这件事情将会变得简单.

### 继承

继承冗余和层叠混淆,虽然两者相关,但是应该分别理解他们.

如果说一个元素的某个属性没有层叠值,则可能会继承某个祖先元素的值,但不是所有属性都能被继承,默认请胯下只有一些属性能被继承, 通常使我们希望继承的,主要是一些文本相关的属性:

color font font-family font-size font-weight font-varint font-style line-height letter-spacing text-align text-indent text-transform white-space word-spacing

#### 特殊值

1. inherit
   使用 inherit 值来用继承踢打一个层叠值
2. initial

使用 initial 来撤销某个元素的样式,相当于硬复位.

#### 简写属性

简写属性是用于同时给多个属性赋值的属性例如:

font 可以设置多种属性,它制定了 font-style font-weight font-size font-height 以及 font-family

```css
font: italic bold 18px/1.2 "Helvetiica", "Arial", sans-serif;
```

还有一些属性支持简写:

- background
- border
- border-width

#### 简写属性会默默覆盖其他样式

大多数简写属性可以省略一些值,只指定我们关心的值,但是要知道.这样仍然会设置省略的值,他们会被隐式的设置为初始值,这会默默覆盖在其他地方定义的样式.

#### 理解简写值的顺序

简写属性会尽量包容指定的属性值的顺序, 但是有很多属性值很模糊,在这种情况下顺序很关键,理解这些简写属性的顺序很重要.

1. 上右下左

当遇到 margin padding 这样的属性,还有为元素的四条边分别指定值的边框属性时,开发者冗余弄错这些简写属性的顺序,这些属性的值是按照顺时针方向开始的.

2. 水平 垂直

有一些属性最多支持指定两个值, 例如 background-position box-shadow text-show ,这种顺序值看起来违背直觉,但是这两个值代表了笛卡尔网格, 一般是按照想 x,y 的顺序来的.

## 相对单位

- 相对单位的广泛用途
- 使用 em 和 rem
- 使用视口和相对单位
- 介绍 css 变量

### 相对单位的优点

CSS 为网页带来后期绑定的样式: 直到内容和样式都完成了,二者才会结合起来,这会给设计流程增加复杂性,而在其他类型的图形设计中是不存在的.好处是一个样式表可以用于成千上百个网页.此外用户还能直接改变最终渲染效果.

#### em 和 rem

em 是最常见的相对长度单位, 适合基于特定的字号进行排版,在 css 中 1em 就等于当前元素的字号.因为 em 会被计算为最终结果,所以称为计算值

#### 使用 em 定义字号

使用 em 定义字号时,em 表现得不太一样, em 会根据当前字号来决定,但是如果使用 em 来定义当前字号这就会进入死循环,实际上当使用 em 来定义字号时,使用的是继承来的字号进行计算的.

#### 使用 rem 定义字号

rem 是 root em 的缩写,rem 不是相对于当前元素,而是相对于根元素的单位,不管在文档的什么位置使用 rem,都会得到相同的计算后的值.

与 em 相比 rem 降低了复杂性, 实际上, rem 结合了 px 和 em 的优点.但是并可以全部应用 rem ,在 CSS 里,答案通常是 看情况. rem 只是你工具包中的一种工具.掌握 CSS 很重要的一点是学会在适当的场景使用适当的工具,一般使用 rem 设置字号, 使用 px 设置边框, 用 em 设定其他大部分属性,尤其是内边距,外边距.

#### 设置一个合理的默认字号

如果希望设置默认字号为 14px, 那么不要将默认字体设置为 10px 然后再覆盖一遍,而应该直接将根元素字号设置为想要的值, 将想要的值除以继承值例如 14 / 16

#### 构造响应式面板

可以使用媒体查询改变根字号,这样就能够对于不同用的屏幕尺寸,渲染出不同大小的面板.

#### 缩放单个组件

有时需要让同一个组件在页面的某些部分显示不同的大小,可以使用 em 来单独缩放一个组件.


#### 视口的相对单位

CSS 里不止有这一种相对单位,还有相对于浏览器可视窗口定义藏毒的视口的相对单位.
- vh 视口高度的1/100
- vw 视口高度的 1/100
- vmin 视口宽.高中较小一方的1/100
- vmax 视口宽.高中较大一方的1/100


例如 50vw等于视口宽度的一半. 25vw等于视口高度的 25%

#### 使用 vw 定义字号

使用 vw 来定义字号,可以在浏览器窗口变化中均匀滨化.不会再某个断点突然变化,当可是大小改变是,元素会逐渐过渡.

#### 使用 calc 定字号

calc 函数内可以对两个及以上的值进行基本运算

使用 calc 结合 em 和 vh 两种单位定义 font-size

```css
:root {
    font-size:calc(0.5em + 1vw)
}
```
这样字体最小会是 0.5em 而最大则会是 1vw + 0.5em



#### 无单位的数值和行高

有些属性允许无单位的值(即一个不指定单位的数),支持这种值的属性包括 line-height z-index font-weight ,任何长度单位都可以用无单位的 0,例如 0px 0% 0em 都可以写成0

line-height属性比较特殊, 他的值既可以有单位也可以无单位,通常应该使用无单位的数值, 因为他们继承的方式不一样



#### 自定义属性(css变量)

2015 新增了层叠量的自定义属性,这个规规范给CSS 引进了变量的概念,开启了一种全新的基于上下文的动态样式,可以声明一个变量,为它赋值,然后在样式表的其他地方引用这个值,可以减少样式表的重复, 并且可以动态改变这个值.

```css 
  /* 定义 */
:root {
    --main-font: Helvetica, Arial, sans-serif;
    --brand-color: #369;
}
/* 使用 */
/* var 支持第二个参数, 如果第一个指定的变量未定义,那么就会使用第二个值 */
.App {
       font-family: var(--main-font);
       color: var(--brand-color, blue);
}



```