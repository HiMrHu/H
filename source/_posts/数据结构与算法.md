---
title: 数据结构与算法
date: 2019-12-29 16:01:49
tags: 算法
---

# 算法

## 分治算法

分治算法基本概念就是`将一个复杂的问题分解成更多的相同或者相似的子问题，进而再将子问题分解为更小的子问题，直到得到一个可以直接求解的简单问题`

而适用分治算法的情况主要有以下几个特征：

1. 问题的规模缩小到一定情况就很容易解决
2. 问题可以被分解为规模较小的相同问题，具有最优子结构
3. 利用子问题的解可以合并为该问题的解
4. 问题所分解的各个问题是独立的，子问题之间不包含公共的子问题

一般而言分治算法的基本步骤如下：

1. 分解 将问题分解为若干规模 相互独立 与原问题相同的子问题
2. 解决 若子问题可以直接被解决 否则继续分解
3. 合并 将各个子问题的解合并为原问题的解

1) [leetcode 多数元素](https://leetcode-cn.com/problems/majority-element/)

leetcode 有这个图

![](https://pic.leetcode-cn.com/3aa2128a7ddcf1123454a6e5364792490c5edff62674f3cfd9c81cb7b5e8e522-file_1576478143567)

```javascript
/**
 * @param {number[]} nums
 * @param {number} k
 * @return {number}
 */
var findKthLargest = function(nums, k) {
  // merge sort
  // 排序占用了额外的空间并不属于 merge sort 排序
  const MergeSort = (l, r) => {
    if (l === r) return [nums[l]];

    const mid = Math.floor((l + r) / 2);

    const left = MergeSort(l, mid);
    const right = MergeSort(mid + 1, r);

    const result = [];

    // [2] [3] == [3,2]
    let idxL = 0;
    let idxR = 0;
    let index = 0;

    // 遍历 有任意超出范围的 则停止
    while (idxL <= left.length && idxR < right.length) {
      if (left[idxL] > right[idxR]) {
        result[index] = left[idxL];
        idxL++;
      } else {
        result[index] = right[idxR];
        idxR++;
      }

      index++;
    }
    // 处理后续工作
    while (idxL < left.length) {
      result[index] = left[idxL];
      idxL++;
      index++;
    }
    while (idxR < right.length) {
      result[index] = right[idxR];
      idxR++;
      index++;
    }
    return result;
  };

  return MergeSort(0, nums.length - 1)[k - 1];
};
```

```python
# 原地 quick sort
'''
这个算法 过不了 LeetCode 他有一个5000元素的数组，但是会直接超时，超过递归最大深度
'''
class Solution:
    def findKthLargest(self, nums: List[int], k: int) -> int:
        self.sort(nums, 0, len(nums) - 1)
        return nums[k - 1]

    def partition(self, array: List[int], L: int, R: int):
        if (L == R):
            return

        pivot = array[R]

        partitionIndex = L
        index = L

        while(index < R):
            if (array[index] > pivot):
                array[partitionIndex], array[index] = array[index], array[partitionIndex]
                partitionIndex += 1
            index += 1

        array[partitionIndex], array[index] = array[index], array[partitionIndex]

        return partitionIndex

    def sort(self, array: List[int], L: int, R: int):
        if (L < R):
            partitionIndex = self.partition(array, L, R)
            self.sort(array, L, partitionIndex - 1)
            self.sort(array, partitionIndex + 1, R)
```
