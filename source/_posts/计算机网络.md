---
title: 计算机网络
date: 2019-11-23 17:34:33
tags: 网络
---

计算机网络笔记 - 自顶向下的方法
<!-- more -->



# 计算机网络和因特网

## 网络核心

### 分组交换

​		一般而言，从源端系统向目的端发送一个报文, 源将长报文划分为较小的数据块, 称之为分组, 在源和目的地之间, 每个分组都通过通信链路和`分组交换机`传送. (交换机主要有两类: `路由器`和`链路层交换机`).  



> ​		分组以等于该链路`最大`传输速率的速度传输通过电信链路,因此如果某源端系统或分组交换机经过一条链路发送一个 L 比特的分组, 链路的传输速率为 R bit/s, 则传输该分组的时间为 L/R s.



### 排队延时和分组丢失

​		对于每条相连的链路,该分组交换机具有一个`输出缓存`(也称输出队列), 因此当该链路忙于传送其他分组, 该分组必须在输出缓存中`等待`. 因此除了转发延时, 分组还要承受数据缓存的`排队时延`, 时延是变化的, 主要取决网络拥堵的程度, 又因为缓存空间有限, 当缓存空间使用完毕, 将出`分组丢失`也就是`丢包` ,到达的分组或已经排队的分组之一将被丢弃.



### 转发表和路有选择协议

​		在因特网中,每个端系统具有一个被称为 IP 地址的地址, 当源主机箱目的端系统发送一个分组时, 源在该分组的首部包含了`目的地的 IP 地址`, 当一份到达网络中的路由器时, 路由器检查该分组的目的地的`一部分`并向一台相邻的路由器转发该地址, 每台路由器具有一个`转发表`,用于将目的地址(护着地址的一部分) 映射称为输出链路. 路由器会检查分组的地址, 并使用转发表将分组导向到适当的链路中.



### 电路交换

​		通过网络链路和交换机移动数据有两种基本方法: `电路交换`和`分组交换`.

​		在电路交换网络中,在端系统通信会话期间,`预留了`端系统间沿路径通信所需要的资源(缓存,链路传输速率), 而在分组交换网络中, 这些资源则`不是预留的`, 会话的报文按需使用这些资源, 其后果可能是不得不等待接入通信线路.



电路交换网络中的复用

​		链路中的电路通过`频分复用`(Frequency-Division Multilexing, FDM)或`时分复用`(Time-Division Multiplexing, TDM)来实现, 对于FDM, 链路的频谱由跨越链路创建的所有连接共享, 在连接器件链路为每条连接专用一个频段,例如在一条链路中电话通常是 4kHz, 而调频无线电通常为88 - 108kHZ的频谱, 其中每个电台被分配一个特定的频段.

​		而对于TDM链路,时间被分为固定期间的帧, 并且每个帧又被划分为固定数量的间隙,当网络跨越一条链路创建一条连接时, 网络在每个帧中为该链接制定一个间隙. 这些间隙专门由该链接单独使用, 一个时隙(在每个帧内)可以用于传输该链接的数据.

 



分组交换和电路交换的区别:

- 分组交换可能会有不可预测的延迟,而电路交换则是固定的
- 分组交换可以更高效的利用宽带,而且他比电路交换简单有效实现成本更低,而电路交换则更好相反



### 分组交换网中的时延,丢包和吞吐量

​		分组从一台主机(源)出发, 通过一系列路由器传输, 在另一台主机(目的地)中结束他的历程. 当分组从一个节点(主机或者路由器)沿着这条路径到达后续节点(主机或者路由器), 该分组在沿途的每个节点经受了几种不同类型的时延, 其中最重要的是以下集中时延:

- 节点处理时延

- 排队时延

- 传输时延

- 传播时延

  以上时延相加结果就是节点总时延



### 时延的类型

1. 处理时延

   ​		检查分组首部和决定该分组导向何处所需要的时间是`处理时延`的一部分. 高速路由器的处理时延通常是微秒或者更低的数量级.

2. 排队时延

   ​		在队列中,当分组在链路上传输时, 它经受`排队时延`, 分组的排队时延取决于链路中等待传输的分组数量,如果队列是空的则时延为0, 如果流量很大,则该队列会很长, 时延将会变长, 实际的排队时延可以是毫秒级到微秒级.

3. 传输时延

   ​		嘉定分组以先到先服务方式传输----这在分组交换机中是常见的额方式, 仅当所有已经到达的分组被传输后, 才能传输刚到达的分组. 例如对于一条 10Mbps 的以太网链路, 速率是R=10Mbps,`传输延时`是L/R, L是该分组的长度.实际的传输时延通常在毫秒到微秒量级

4. 传播时延

   ​		一旦一个 bit 被推向链路, 该比特需要向路由器 B 传播, 从该链路的起点到路由器 B 传播所需要的时间就是`传播时延`. 这取决于传播链路的物理媒介, 在广域网中, 传播时延通常为毫秒量级.

5. 传输时延和传播时延的比较

   ​		两者的差异是微秒而重要的, 传输时延是路由器推出分组所需要的时间, 他是分组长度和链路传输速率的函数,而与两台路由器之间的距离无关, 而传播时延是一个 bit 从一台路由器传播到另一台路由器所需要的时间,他是两个路由器之间距离的函数, 而与分组长度或链路传输速率无关.



### 协议分层

​		因特网的协议栈有五个层次组成: `物理层` `链路层` `网络层` `传输层` `应用层` 

#### 应用层

​		应用层是网络应用程序及他们的应用层协议存留的地方,因特网的应用层有很多协议,例如 HTTP SMTP FTP 等,还有域名系统 DNS.

​		应用层协议分布在多个端系统上,从一个段系统的应用程序使用协议与另一个端系统中的应用程序交换信息分组, 这种位于应用层信息分组称为报文.

#### 运输层

​		英特网的运输层在应用程序之间传送应用层报文, 在英特网中,有两种运输协议, 即 TCP 和 UDP ,  TCP 向它的应用层提供了面向连接的服务,这种服务包括了应用层报文向目的地的确保传递和流量控制, TCP 也将长报文分为短报文,并提供拥塞控制机制,因此当网络拥塞是,源一致其传输速率, 而 UDP 协议向他的应用程序提供无连接服务,这一种不提供不必要服务的服务, 没有可靠性, 没有流量控制,也没有拥塞控制.

#### 网络层

​		因特网的网络层负责将称为`数据报`的网络层从分组从一台主机移动到另一台主机,

#### 链路层

​		因特网的网络层通过源和目的地之间的一系列路由器路由数据报,为了将分组从一个节点(主机或路由器)移动到路径的下一个节点,网络层必须依靠该链路层的服务.特别是在每个节点,网络层将数据报下传给链路层,链路层沿着路径将数据报传给下一个节点,在该下一个节点,链路层将数据报上传给网络层.

#### 物理层

​		物理层的任务是将该帧中的一个个bit从一个节点移动到下一个节点.在这层中的协议仍然链路层相关的,并且进一步与该链路(传输介质)的实际参数媒体相关.



# 应用层

## 应用层协议原理

### 进程与计算机网络之间的接口

​		多数应用程序是由通信进程对组成,每对中的两个进程互相发送报文. 从一个进程向另一个进程发送的报文必须通过下面的网络, 进程通过一个称为`套接字`的软件接口向网络发送报文和从网络接受报文.

> 套接字是同一台主机内应用层与传输层之间的接口,由于该套接字是建立网络应用程序的可编程接口, 因此套接字(socket)也被称为应用程序和网络之间的`应用程序编程接口(Application Programma Interface, API)`.

​		应用程序开发者可以控制套接字在应用端的一切, 但是对于该套接字的运输层几乎没有控制权, 应用程序开发者对于运输层的控制仅限于:

1. 选择运输层协议
2. 也许能设定几个运输层参数,如最大缓存和最大报文段长度等



一旦应用程序开发者选择了一个运输层协议(如果可供选择的话),则应用程序就建立在由该协议提供的运输服务之上.

### 进程寻址

​		例如在想特定目的地发送向邮政邮件, 目的地需要有一个地址,类似的,在一台主机运行的进程向在另一台主机上运行的进程发送分组, 接受进程需要有一个地址,为了标识该接受进程,需要定义两个信息, 主机的地址以及在目的主机中指定接受进程的标识符.

​		而在因特网中,主机由其`IP地址`标识,一般而言发送进程还必须指定运行在接收主机上的接收进程,因为一般而言一台主机能够运行许多网络应用,而目的地的`端口号`则用于这个目的,已经给流行的应用分配了特定的端口号,例如 Web服务使用80来标识,邮件服务使用25标识.

###可用应用程序使用的运输服务

​		包括因特网在内的许多网络提供了不止一种运输协议,开发一个应用时必须选择一个可用的运输协议,对于不同的运输协议大体可以通过一下四种进行分类: `可靠数据传输` `吞吐量` `定时` 和 `安全性`

#### 可靠数据传输

​		分组在计算机中可能丢失,例如丢包,但是对于某些应用,例如银行系统,分组丢失会导致灾难性后果,因此为了支持这些应用,必须做一些工作由应用程序的一段发送的数据正确和完整的交付给该应用程序的另一端, 如果一个协议提供了这样的确保数据交付的服务,就认为提供了`可靠数据传输`,运输层协议能够潜在的向应用程序提供的一个重要服务是进程到进程的可靠数据传输. 当一个运输协议提供这种服务时,发送进程只需要将其数据传递进套接字,就可以完全相信该数据将能无差错地到达接受进程.

​		当一个运输层协议不提供可靠数据传输时, 由发送进程发送的某些数据可能达到不了接收进程,这可能能被`容忍丢失的应用`所接受,如视频,音频应用中丢失部分数据会出现小干扰,而不是致命的损伤

#### 吞吐量

​		可用吞吐量就是发送进程能够像接收进程交付bit的速率,因为其他会话将功效沿着该网络路径的宽带,并且因为该到达和离开,该可用吞吐量会随时间波动,具有吞吐量要求的应用程序被成为`宽带敏感的应用`,宽带明爱的应用具有特定的吞吐量要求, 而`弹性应用`能够根据当时可用的宽带或多或少的利用可用使用的吞吐量, 例如电子邮件,文件传输,Web传送都属于弹性应用.

#### 定时

​		运输层协议也能提供定时保证,如同具有吞吐量那样的保证,例如保证发送方注入套接字中的bit不迟于100ms到达接收方.

#### 安全性

​		运输协议能够为应用程序提供一种或者多种安全性服务,例如在发送主机中,运输协议能够加密发送进程传输中的所有数据,在接收主机中,运输协议能够在将书记交付给接收进程之前解密这些数据.



### 因特网提供的运输服务

​		因特网(更一般的是TCP/IP网络)为应用程序提供了两个运输协议,即 UDP 和 TCP, 所以当为英特网提供一个新的应用程序时,首先要考虑的决定是: 使用 UDP 还是 TCP , 每个协议为调用他们的应用程序提供了不同的服务集合



#### TCP

​		TCP 服务模型包括面向连接服务和可靠数据传输服务, 当某个程序调用TCP作为其运输协议时, 该应用程序就能获得来自TCP的这种服务.

1. 面向连接的服务

​		在应用层数据报文开始流动之前, TCP 让客户和服务器互相交换运输层控制信息, 这个所谓的握手过程是提醒客户和服务器,让他们为大量分组的到来做好准备, 在握手阶段后,一个 TCP 连接就在两个进程的套接字之间建立,这条连接时双工的,即连接的双发的进程可以在此连接上同事进行报文手法,当应用程序结束报文发送时,必须拆除该连接.

2. 可靠的数据传送服务

   通信能够依靠TCP,无差错并且按照适当的顺序交付所发送的数据,当应用程序的一段将字节流传进套接字时,它

能够依靠 TCP 将相同的字节流交付给接收方的套接字,而没有字节的丢失和冗余.

​		TCP 协议还具有拥塞控制机制,这种服务并不一定能为通信进程带来直接的好处,但能为因特尔网络带来整体的好处,当发送放和接收方网络出现拥塞时, TCP 的拥塞控制会一致发送进程. TCP 拥塞控制也试图限制每个 TCP 连接,使他们达到公平共享网络宽带的目的.



#### UDP

​		UDP 是一种不提供不必要服务的轻量级运输协议, 它仅提供最小服务, UDP 是无连接的, 因此在两个进程通信前是没有握手过程的, UDP协议提供一种不可靠数据传送服务, 当进程讲一个报文发送进 UDP 套接字时, UDP 协议并不保证该报文将到达接收进程,而且到达接收进程的报文也可能是乱序到达的.



### 应用层协议

​		`应用层协议`定义了运行在不同端系统上的应用程序进程如何相互传递报文. 特别是应用层协议定义了:

1. 交换的报文类型,比如请求报文和响应报文
2. 各种报文类型的语法, 如报文中的各个字段以及这些字段是如何描述的
3. 字段的语义,即这些字段中的信息的含义
4. 确定一个进程何时如何发送报文,对报文进行响应的规则

​		Web的应用层协议时HTTP, 它定义了浏览器和Web服务器之间传输的报文格式和序列,因此, HTTP只是Web的一个部分,尽管是一个重要的部分,又例如邮件系统的应用层协议就是SMTP(简单邮件传输协议),因此邮件的首要应用层协议SMTP也只是电子邮件应用的一个部分.



###  Web 和 HTTP

 #### HTTP 概况

​		Web 的应用层协议是`超文本传输协议`(HyperText Transfer Protocol, HTTP),  它是 Web 的核心, HTTP 由两个程序实现: 一个客户程序和一个服务器程序. 客户程序和服务程序运行在不同的端系统中,通过交换HTTP报文进行会话,HTTP 定义了这些报文的结构以及客户和服务器进行报文交换的地方. 客户想他的套接字接口发送和接收HTTP报文,一旦客户向他的套接字接口发送了一个请求报文,这个报文就脱离了客户端控制并且进入TCP控制, 而TCP为HTTP提供可靠的数据传输服务.



#### 非持续连接和持续连接

​		在许多因特网应用程序中,客户和服务器在一个想当长的时间范围内通信,其中客户发出一系列请求并且服务器对每个请求进行相应,客户-服务器交互式通过TCP进行的,那么程序的研制者就要做出一个重要的决定,即每个请求/响应式经单独的TCP进行还是所有的请求和响应通过相同的TCP连接发送,采用前一种方法,该应用程序被称为使用`非持续连接`采用后一种方法,该应用程序被称为使用`持续连接`



#### 采用非持续连接的HTTP

​		当采用非持续连接情况下,服务器向客户端发送一个 Web页面的步骤:

1. HTTP客户进程在80端口发起一个到服务器的TCP连接
2. HTTP 客户经他的套接字向该服务器发送一个HTTP请求报文,报文中包含了所需要的资源
3. HTTP 服务器进程经他的套接字接收到该请求报文,并在一个HTTP响应报文中封装对象,并通过其套接字向客户发送响应报文
4. HTTP服务器进程通知TCP断开该TCP连接(但是直到TCP确认客户已经完整的收到响应报文,它才会实际中段连接)
5. HTTP客户收到响应报文, TCP 连接关闭, 并解析报文,从中读取资源或者资源地址,对于地址重复以上步骤得到资源.



​		上面步骤说明了非持续连接的使用,其中每个TCP连接在服务器发送一个对象后关闭,该链接并不为其他的对象而持续下来.

​		浏览器和Web服务器之间发起一个TCP连接,涉及一次"三次握手"过程,即客户想服务器发送一个小TCP报文,服务器用一个小的TCP报文做出确认响应,最后客户想服务器返回确认, 三次握手中前两部分所消耗的时间占用一个`往返时间`,完成三次握手的前两部分后,客户结合三次握手的第三部分(确认)向该TCP链接发送一个HTTP请求报文,一旦该请求报文送达服务器,服务器就在该TCP连接上发送响应,该HTTP请求/响应用去了另一个`往返时间`因此粗略讲总的响应时间就是两个`往返时间`加上服务器传输HTML文件的时间.



#### 采用持续的HTTP

​		非持续连接的缺点:

1. 必须为*每一个请求的对象*建立和维护一个全新的连接,对于每个这样的连接,在客户和服务中都要分配TCP的缓冲区和保持TCP变量,这给服务器带来了严重的负担.
2. 每一个对象需要经受双倍的`往返时间`即一个用于创建TCP的往返时间,一个用户请求和接收一个对象的往返时间

在采用HTTP1.1持续连接的情况下服务器在发送响应后保持该TCP连接打开,在相同的客户与服务器之间,后续的请求和报文能够通过相同的连接进行传输, 这样可以节省资源和加快响应时间.一般来说一条连接经过一定时间间隔(可配置的间隔)仍未被使用, HTTP 服务器就关闭该连接,HTTP的默认模式是使用带流水线的持续连接, HTTP/2是子HTTP1.1基础上构建的,他允许在相同的连接中多个请求和回答交错,并增加了该连接中优化HTTP报文请求和回答机制.



#### HTTP报文格式

​		HTTP规范包含对HTTP格式的定义,HTTP报文有两种:`请求报文`和`响应报文`

		>```html
		>// 请求报文
		>GET / HTTP/1.1
		>Host: developer.mozilla.org
		>Accept-Language: fr
		>```

​		报文使用普通的ASCII文本, 又若干行组成,每一行由一个回车和换行符结束,最后一行在附加一个回车换行符.

HTTP请求报文的第一行叫做`请求行`后继的行叫做`首部行`请求航有三个字段:`方法字段` `URL` 和 `HTTP版本`字段

> ```html
> // 响应报文
> HTTP/1.1 200 OK
> Date: Sat, 09 Oct 2010 14:28:02 GMT
> Server: Apache
> Last-Modified: Tue, 01 Dec 2009 20:18:22 GMT
> ETag: "51142bc1-7449-479b075b2891b"
> Accept-Ranges: bytes
> Content-Length: 29769
> Content-Type: text/html
> 
> <!DOCTYPE html... (here comes the 29769 bytes of the requested web page)
> ```

​		想一个报文包含三个部分: 一个初始`状态行`, 若干`首部行`然后是`实体体`



#### cookie

​		HTTP 是无状态的,这简化了服务器的设计,HTTP中使用了cookie,来对用户进行追踪,识别以及限制.



#### Web 缓存

​		Web 缓存(Web cache) 也叫代理服务器,它能代表初始Web服务器来满足HTTP请求的网络实体.Web缓存器有自己的磁盘储存空间,并且在存储空间中保存最近请求过的对象的副本.在因特网中部署Web缓存浏览器有两个原因,首先Web缓存器可以大大减少对客户请求的响应时间,Web缓存器能从整体上大大降低因特网上的Web流量,从而改善所有应用的性能.



### 英特网中的电子邮件



#### SMTP

​		SMTP(Simple Mail Transfer Protocol, SMTP), 是电子邮件中的主要应用协议, 它使用 TCP 可靠数据传输, SMTP 问世的时间比 HTTP 要长的多, 一般而言 SMTP 不适用中间邮件服务器发送邮件,及时这两个服务器位于地球的两端.

​		HTTP 协议和 SMTP 协议中药的一些区别, HTTP 通常是从服务器上拉取数据,而SMTP通常是通常是推数据,SMTP要求每个报文(包括他们的体)采用7bit ASCII 码格式,如果报文包含了非7bit ASCII 字符 或者二进制数据,则该报文必须按照7bit ASCII 码进行编码, HTTP 则不收这种限制, 对于一个既包含文本又包含图形(或者其他媒体)的文档,HTTP吧每个对象封装到他自己的HTTP响应报文中,而SMTP则吧所有对象放在一个报文中.



#### POP3

​		POP3 是一种极为简单的邮件访问协议,简短并且可读性强, 因为协议简单,故功能业有限,当用户打开了一个到邮件服务端口110上的TCP连接后, POP3 就开始工作了, 随着TCP连接, POP3 按照三个阶段进行工作, `特许`  `事务处理` `更新`, 在特许结局单,用户代理发送明文用户名和口令鉴别用户,  事务处理阶段,用户取回报文, 同事在这个阶段用户还能做如下操作: 对报文做删除标记, 取消报文删除标记,以及获取邮件的统计信息. 在更新阶段, 他出现在客户发出了 quit 命令之后, 目的是结束该 POP3 会话,这时邮件服务器应该删除那些被标记为删除的报文.

#### IMAP

​		使用POP3访问时,一旦邮件下载到本级后,就可以建立邮件文件夹,并将下载的邮件放入文件夹中,并且可以操作这些文件夹,但是用户可能更喜欢使用一个在远程服务器上的层次文件夹, 使用POP3是不可能做到这一点的, POP3协议没有给yoghurt提供任何创建远程文件夹并为报文指派文件夹的方法,

​		为了解决这些问题, IMAP邮件访问协议诞生了, 和POP3一样,IMAP是邮件访问协议,但是他比POP3 具有更多特色,并且也比POP3复杂的多(客户端和服务端实现都比POP3复杂)

​		IMAP 服务器把每个报文和文件夹联系起来,当报文第一次到达服务器是,它与收件人的INBOC文件夹关联,收件人则能吧邮件移动到一个新的,用户创建的文件夹中,阅读邮件,删除邮件等.



### DNS: 因特网的目录服务

​		在英特网中,主机和人类一样,可以使用多种方式进行标识,主机表示法是使用它的`主机名`,然而主机名技术没有提供关于主机在英特网中的位置信息,所以主机也可以使用所谓的`IP地址`进行标识.



#### DNS提供的服务

​		人类对名称比较敏感,也便于记忆,而机器更喜欢定长的有层次结构的IP地址,为了折中这些不同的偏好,需要一种能进行主机名到IP地址转换的目录服务,这就是`域名系统(Domain Name System, DNS)`的主要任务

​		DNS是:

1. 一个由分层的DNS服务器实现的分布式数据库
2. 一个使得主机能够查询分布式数据库的应用层协议,DNS服务器通常是运行BIND(Berkeley Internet Name Domain) 软件的 UNIX 机器, DNS 协议运行在 `UDP` 之上 使用 53 端口



​		DNS 通常是由其他应用层协议所使用, 包括 HTTP SMTP FTP 等, 将用户提供的主机名解析成一个IP地址.大体流程如下:

1. 浏览器从 UTL 中抽取主机名,并将这个主机名传给DNS应用的客户端
2. DNS 客户向DNS服务器发送一个包含主机名的请求
3. DNS客户最终后收到一份回答报文,其中含有对应于该主机名的IP地址
4. 一旦浏览器收到来自DNS的该IP地址,它能够向位于IP地址80端口的HTTP服务器进程发起一个TCP



​		从例子中可以看到DNS给其他的应用带肋了额外的延迟,并且有时延时还相当可观,幸运的是,通常IP地址通常就缓存在一个"附近"的DNS服务器中,这有助于减少DNS的网络流量和DNS的平均延迟.

​		

​		除了进行主机名到IP地址的转换之外,DNS还提供一些重要服务:

1. 主机别名,许多主机拥有很多不同的主机别名,应用程序可以调用DNS来获得主机别名对应的规范主机名以及主机的IP地址
2. 邮件服务器别名, 邮件应用程序可以调用DNS,对提供的主机别名进行解析,已获得该主机的规范主机名及其IP地址,事实上,MX记录允许一个公司的邮件服务器和Web服务器使用相同的主机名,即Web服务器和邮件服务器可以使用同一个地址
3. 负载分配,DNS也用于在冗余的服务器(如冗余的Web服务器等)之间进行负载分配.



	#### DNS工作机理概括

​		DNS 的一种简单涉及是在因特网上只使用一个DNS服务器, 该服务器包含所有的额映射,在这种集中式的设计中,客户直接将所有查询直接发送往单一的DNS服务器,同事该DNS服务器直接对所有的查询客户做出相应, 因为因特网有着数量巨大(并持续增长)的主机,这种集中式的实际问题包括:

1. 单点故障, 如果该DNS服务器崩溃,整个因特网随之瘫痪
2. 通信容量,单个服务器不得处理所有的DNS查询
3. 远距离的集中式数据库, 单个服务器不可能"临近"所有查询客户.这可能会导致低速拥塞的链路
4. 维护,单个DNS服务器将不各部位所有的英特网主机保留记录,这将会是中央数据库庞大,并且为了解决这个问题而频繁更新



#### 分部署,层次数据库

​		为了处理扩展性,DNS使用了大量的DNS服务器,使用层次方式组织,并且分布在全世界范围内.将逐渐映射分布在所有的DNS服务器上,大致有三种服务器,`根DNS服务器` `顶级域DNS服务器` 和`权威DNS服务器`

1. 根DNS服务器,有400多个根DNS服务器分布在全世界,由13个不同的组织管理.
2. 顶级域DNS服务器,对于每个顶级域如com net 和国家级顶级域 cn 都有TLD服务器, TLD服务器提供了权威DNS服务器的IP地址
3. 权威DNS服务器,在因特网上具有公共可访问主机例如 8.8.8.8



​		还有一种另类的重要DNS服务器,称为本地DNS服务器, 严格来说并不属于该服务器的层次结构,但是他对DNS层次结构是至关重要的



#### DNS 缓存

​		DNS缓存在英特网上广泛使用,以改善时延性能并减少因特网到处传输的DNS报文数量,一般DNS服务器在过一段时间后就会清除缓存.



#### DNS 记录和报文

​		共同实现DNS分布式数据库的所有DNS服务器储存了`资源记录(Resource Record,RR)`, RR 提供了主机名到IP的地址映射,资源记录是包含了如下字段的四个元组:

> (Name, Value, Type, TTL)

​		TTL是记录生存时间, 他决定而来资源记录应当从缓存中删除的时间,Name 和Value 的值取决于 Type

- 如果Type = A, 则Name是主机名,Value是该主机对应的IP地址,这就是一条类型A记录
- 如果Type = NS, 则 Name 是个域(如a.con), 而 Value 是个知道如何获得该域中主机IP地址的权威DNS服务器的主机名
- 如果Type = CNAME, 则 Value 是别名为 Name 的主机对应的规范主机名, 该记录能够查询主机提供一个主机名对应的规范主机名.
- 如果 Type = MX , 则 Value是一个别名为Name的邮件服务器的规范主机名

​		

###视频流和内容分发网

#### HTTP流和DASH

 		在HTTP流中,视频只是储存在HTTP服务器中作为一个普通的文件,每个文件有一个特定的URL,当用户请求该视频时,客户与服务器创建一个TCP连接发送对该URL的HTTP的GET请求,服务器则以底层网络协议和流量条件允许的尽可能快的速率,在一个HTTP响应报文中发送视频文件,在客户一侧,字节二笔手机在客户应用缓存中,一旦缓存的字节超过预先设定的门限,客户应用就开始播放

​		尽管HTTP流在实践中得到了广泛部署,但是它具有严重的缺陷,即所有客户收到相同编码的适配,尽管客户可用的宽带大小不同,这导致了一种新型基于HTTP的流的研发,在DASH中,视频编码为几个不同的版本,其中每个版本都具有不同的bit率,对于不同的质量水平,客户动态的请求来自不同版本且长度为几秒的数据块,当可用宽带较高,客户自然选择高速率的版本,反之选择低速率版本

​		DASH 允许客户使用不同的以太网接入速率播放具有不同编码率的视频,当使用DASH之后,每个视频版本储存在HTTP服务器中,每个版本都有不同的URL.



#### 内容分发网

​		为了应对向分布于全世界用户分发巨量视频数据的挑战,几乎所有主要视频公司都会利用`内容分发网`(Content Distribution Network,CDN)



1. CDN 操作,当用户主机中的一个浏览器指令检索一个特定的视频(由URL标识),CDN必须截获该请求以便可以: 确定此时适合该用户的CND服务器集群,将客户的请求重定向到该集群的某个服务器,
2. 集群选择策略, 任何CDN部署,核心都是集群选择策略,即动态的将客户定向到CND中的某个服务器集群或者数据中心机制,一种简单的策略是指派客户到`地理位置最为近邻`的集群.



### 套接字变成: 生成网络应用

​		网络应用程序有两类,一类由协议标准中定义的操作实现,这种应用程序被称为开放的,另一类网络应用程序是专用的,有客户和服务器程序应用的应用层协议没有公开,有单独的开发者用他的代码实现的功能.

​		[C++ 代码实现 socket应用](https://github.com/HiMrHu/socket)



​		与UDP不同的是, TCP 是一个面向连接的协议,这意味着在通信发送数据之前,他们需要握手和创建一个 TCP 连接, 当创建该 TCP 连接时, 将其与客户套接字地址和服务器套接字地址关联起来, 使用创建的 TCP 连接, 当一侧向另一侧发送数据, 他只需要经过其套接字将数据丢进 TCP 连接,这与 UDP 不同, UTP 服务器在将分组都进套接字之前还必须为其附上一个目的地址.

​		

​		首先客户端向服务器发起接触任务, 服务器为了能够对客户的初始接触做出反应, 必须已经做好准备,这意味着:第一, 与 UDP 一样, TCP 服务器在客户视图发起接触钱必须作为进程运行起来, 第二, 服务器必须具有一扇特殊的门, 更精确的说是个特殊的套接字,  该问欢迎来自运行在任意主机上的客户进程的某种初始媒介, 使用房子与门来比喻进程与套接字.

​		随着服务器进程运行,客户端向服务器发送一个 TCP 连接, 由客户程序听过创建一个 TCP 套接字完成的, 当客户生成其 TCP 套接字时, 它制定了服务器中的换乘套接字地址,即服务器主机的IP地址及其套接字的端口号,生成其套接字后, 该客户发起了一个三次握手并创建于服务器的一个 TCP 连接, 发生在运输层的三次握手,对客户和服务器程序是完全透明的.

​		三次握手之间,客户端敲服务器进程的欢迎之门,当该服务器接收到敲门声,它将生成一扇新门(新的套接字),它专用于特定的客户(连接套接字), 之后客户端可以通过这个套接字发送任意字节,并且 TCP 保证服务器进程能够按发送的顺序接收每个字节, TCP 因此在客户和服务器进程之间提供了可靠服务.当然服务器不仅能够从这个套接字中接收字节,也能发送字节.

- [Web 服务器](https://github.com/HiMrHu/socket/tree/master/TCP_Web)



## 运输层

### 概述和运输层服务

​		运输层协议为运行在不同的应用进程之间提供了`逻辑通信`功能,  通过应用程序的角度看, 通过逻辑通信,运行不同进程的主机好像直接连接在一起.

​		运输层协议时在端系统而不是在路由器中实现的, 在发送端,运输层从发送应用程序进程接收到的报文转换成运输层分组, 实现方法(可能)是将应用报文划分为较小的块, 并为每块加上一个运输层首部以生成运输报文段,然后在发送端系统规划中,运输层将这些报文段传递给网络层,网络层将其封装成网络层分组并向目的地发送, 网络路由器仅作用于该数据报的网络层字段,不会检查封装在数据报运输层报文段的字段,在接收端,网络层从数据报中提取运输层报文段,并将该报文段向上交给运输层,运输层则处理接收到的报文段,使该报文段中的数据为接收应用程序使用.



### 运输层和网络层的关系

​		在协议栈中,运输层位于网络层智商,网络层提供了主机之间的逻辑通信,而运输层为运行在不同主机上的进程之间提供了逻辑通信,

​		

### 英特网运输概述

​		UDP (用户数据报协议),它为调用它的应用程序提供了一种不可靠,无连接的服务, TCP(传输控制协议),它为调用它的应用程序提供了一种可靠的,面向连接的服务.应用程序开发人员在生成套接字时必须指定选择UDP或者TCP.

​		因特网网络层协议还有一个名字叫IP, 即网际协议,IP为主机之间提供了逻辑通信,IP的服务模型就是`尽力而为交付服务`,但是也不做任何确保. 即不确保报文交付,不确保报文的按序交付,不确保报文中数据的完整性.也是由于这些原因,IP被称为`不可靠服务`, 每台主机至少有一个网络层地址,即所谓的IP地址.

​		UDP和TCP最基本的责任是,将两个系统间IP的交付服务扩展为运行在端系统上的两个进程之间的交付服务,将主机间交付扩展到进程间交付被称为`运输层的多路复用`与`多路复用`.

​		TCP微应用程序提供了几种附加服务,首先提供了`可靠数据传输`,通过使用流量控制,序号,确认和定时器,TCP确保正确的,按序的将数据从发送进程交付给接收进程.TCP还提供了`拥塞控制`TCP拥塞控制防止任何一条TCP连接用过多地流量来研磨通信主机之间的链路和交换设备,TCP力求每个通过一条拥塞网络的连接平共享链路宽带,这样可以通过调节TCP连接的发送端发送进网络链路的流量速率来做掉,在另一方面UDP流量是不可调节的,使用UDP传输应用可以根据其需要以其愿意的任何速率发送数据.



### 多路复用与多路分解

  

>   多路复用与多路分解服务是所有计算机网络都需要的

​		考虑一台主机如何将接收到的运输层报文定向到适当的套接字, 为此目的,每个运输层报文段中具有几个字段,在接收端,运输层检查这些字段, 标识出接收套接字,从而将报文定向到套接字内,将运输层报文的数据交付到正确的套接字工作成为`多路分解`, 在源主机从不同套接字中接收数据块,并为每个数据块封装封装上首部信息(这将在以后用于分解)从而生成报文段,然后将报文段传递到网络层,这些工作成为多路复用.

​		运输层多路复用要求:

1. 套接字有唯一标识符
2. 每个报文段有特殊字段来指示该报文段所要交付到的套接字,这些特殊字段是`端口号字段` 和 `目的地端口号字段`(UDP和TCP报文还有一些其他字段),端口号是一个16bit的数,其大小在0 - 65535之间, 0 - 1023 端口号被称为`周知端口号`,使用时受限制的,他们被指派并保留给诸如HTTP FTP 之类的协议使用.



​		在主机上的每个套接字能够分配给一个端口号,当报文段到达主机时,运输层检查报文段中的目的地端口号,并将其定向到相应的套接字,然后报文段中的数据通过套接字进入其所连接的进程.TCP中的多路复用和多路分解比UDP复杂.

​		当创建一个UDP套接字时,运输层自动为该套接字分配一个端口号,特别的是运输层从范围1024 - 65535 内分配一个端口号, 该端口号是当前一个未被该主机中任何其他UDP端口使用的号,另一种是通过创建UDP套接字之后可以使用bind方法给这个UDP套接字关联到一个特定的端口号

​		一个UDP套接字有一个二元组全面标识,该二元组包含一个目的IP地址和一个目的地的端口号,因此如果两个UDP报文段有不同的源IP地址和/或源端口号,但是具有相同目的IP地址和目的地的端口号,那么这两个报文将通过项目的目的地套接字被定向到相同的目的地进程.

​		TCP套接字由一个四元组(源地址IP,源端口号,目的地IP,目的地端口号)来标识,因此当一个报文段从网络到达一台主机时,该主机使用全部四个值将报文定向(分解)到响应的套接字,特别的是与UDP不同,两个具有不同原地址或者源端口号到达TCP报文将被定向到两个不同的套接字,除非TCP报文携带了初始创建连接请求.



### 无连接运输: UDP

​		由[RFC768]定义的UDP只是做了运输协议能够做的最少工作,除了复用/分解功能以及少量的差错检验之外,他几乎没有对IP增加别的东西,如果是用UDP那么应用程序基本上就是直接与IP打交道,UDP从应用进程得到数据,附加上英语多路复用/分解服务的源和目的地端口号字段,以及其他的两个小字段,然后形成报文段交给网络层,网络层将该运输协议封装到一个IP数据报中,然后尽力而为尝试将次报文段交付给接收主机,使用UDP时发送方和接收方的运输实体层没有握手,所以UDP被称为是无连接的.

​		TCP和UDP差异以及不同情况下的优劣

1. TCP在关于发送什么数据以及何时发送多的应用层控制更为精细

   采用UDP时,只要将应用进程数据传递给UDP,UDP就会将次数据打包进UDP报文,,并立即传递给网络层,而TCP用用拥塞控制机制,一遍当源和目的主机间的一条或者多条链路拥塞时来遏制运输层TCP发送方.TCP会将接收方未收到的数据报文重新发送,直到目的主机收到此报文并加以确认,而不管可交付需要多长时间,对应的如果允许少量丢失,以及对速度要求都可以使用UDP.

2. UDP无需建立连接

   TCP在开始数据传输之前要进行三次握手,UDP缺不需要任何准备即可进行数据传输, 因此UDP不会有建立连接时的延迟

3. UDP无连接状态

   TCP需要在端系统中维护连接状态,此链接状态包括接收和发送缓存,拥塞参数控制以及序号与确认序号的参数,要实现TCP的可靠数据传输服务并且提供拥塞控制,这些信息是必要的.而UDP不维护连接状态,也不跟踪这些参数,因此某些程序运行在UDP之上能比TCP支持更多活跃用户.

4. 分组开销小

   TCP报文端都有20字节的首部开销,而UDP仅有8字节的开销



### UDP检验和

​		`UDP检验和`提供了差错检验功能,用于确定当UDP报文段从源到达目的地移动时,其中bit是否发生了改变,方方的UDP对报文段中多有16bit紫的和进行反码运算,求和时遇到的任何一处都被回卷,得到的结果被放在UDP报文段中的检验和字段中.



### 可靠数据传输原理

​		可靠数据传输的实现问题不仅在运输层出现,也会在链路层以及应用层出现.一般来说性能问题对网络来说更为重要,而在其他重要问题中可靠数据传输则是有力竞争选手.

​		

### 构造可靠数据传输协议

​		通过一步一步研究协议,实现一个完美可靠的传输协议



1. 最简单的情况是,底层信道是完全可靠的,即发送出去的信息一定会被送到.不会出任何差错而且假定发送方速率和接收方速率相等. --底层信道可靠,不会传输出错,速率相等   协议0.1

2. 底层信道更为实际的模型是分组中的比特可能受损,在分组传播或缓存过程中,bit差错可能会出现网络的部件中,因此要实现可靠的数据传输协议,必须解决这个问题,在计算机网络中基于一种被称为自动重传请求的协议来实现可靠数据传输,自动重传请求协议还需要其他另外三种协议工来来处理比特差错情况
   1. 差错检测,  需要一种机制以使接收方检测到何时出现了比特差错.类似于UDP的差错和.
   2. 接收方反馈, 因为接收方和发送方通常在不同端系统上执行,发送方需要了解接收方情况的唯一途径就是让接收方提供明确反馈信息给发送方.
   3. 重传, 接收方收到由差错的分组时,发送方将重传该分组
   
   此时便得到了拥有:检查错误,接受反馈和重传机制的 协议0.2
   
3. 现在除了假定比特受损外,还要考虑到底层信道还会丢包, 通常会设定一个时间阈值,超过这个值之后就会被认定为丢包, 所以使用倒计数定时器基于重传来实现这个功能,在一个给定时间量过期后,终端发送方,因此发送方徐亚能做到:

   1. 每次发送一个分组(包括第一次分组和重传分组)时,便启动一个定时器
   2. 响应定时器中断(采取合适的操作)
   3. 终止定时器

   便得到了超时重传的 0.3 协议



​		总结数传可靠传输要点: 在检验和, 序号, 定时器, 肯定以及否定确认分组这些技术中,每种机制在协议运行中起到了必不可少的作用,至此得到了一个可靠的数据传输协议.



### 流水线可靠数据传输

​		上面的0.3协议已经是一个功能正确的协议,但是他的性能不是太令人满意特别是在今天的高速网络中

​		解决这个特殊的性能问题的方法是: 不以停等方式运行,允许发送方发送多个分组而无需等待确认,以解决以前必须等到回复才会发送下一个分组所产生的额性能问题.

​		如果可以在回复之前发送三个分组,那么相比较以前利用率提升了三倍,因为许多从发送方向接收方输送的分组可以看成是填充到一条流水线中,故这种技术被称为流水线(pipelining).流水线技术对可靠数据传输协议可带来如下影响:

1. 必选增加序号范围,因为每个传输中的分组必须有一个唯一的序号,而且也许有多个在传输中的未确认报文
2. 协议的双方也不得不缓存多个分组,发送方最低限度能缓存哪些已经发送但没有确认的分组,如下面讨论那样,接收方获取需要缓存哪些已经正确接收的分组
3. 所需需要范围和对缓冲要求取决于数据传输协议如何处理丢失,损坏及延时过大的分组,解决流水线的和差错回复有两种基本方法:`回退N步` 和 `选择重传`

#### 回退N步

​		在回退N步协议中,允许发送方发送多个分组(当多个分组可用时),而不需要等待确认,但它也受限于在刘淑贤中未确认的分组数不能超过某个最大数N. 那些已被发送但还未确认的分组的许可序号范围可以被看成是一个在序号范围内长度为N的窗口,随着协议的运行,该窗口可在序号空间向前滑动,因此,N常被称为`窗口长度`, GBN 协议也被常称为`滑动窗口协议`.

​		GBN 发送方必须响应三种类型事件:

1. 上层的调用.发送方首先检查发送窗口是否已满,即是否有N个已经发送但未被确认的分组,如果窗口未满,则产生一个分组将其发送,并响应更新变量.如果窗口已满,发送方只需将数据返回给上层,隐式地指示上层该窗口已满,然后上层可能过一会再试,在现实中发送方更可能缓存这些数据等待发送.
2. 收到一个ACK.在GBN协议中,对序号为n的分组采取`累积确认`的方式,表明接收方已经正确接收到序号为n的以前包括n在内的所有分组
3. 超时事件,协议的名字`回退N步`来源于出现丢失和时延过长分组时发送方的行为,就像在等停协议中那样,定时器将再次用于恢复数据或确认分组的丢失,如果出现超时,发送方重传所有已发送但是还未被确认过的分组,如果收到一个ACK,但仍有已发送未被确认的分组,则定时器被重新启动,如果没有已发送但未被确认的分组,停止该定时器

#### 选择重传

​		GBN协议潜在的允许发送用多个分组`填充流水线`因此避免了协议中提到的信道利用率的问题,然而GBN本人也存在性能问题,尤其是当前窗口长度和宽带延迟都很大的时候,在流水线中会有很多分组更是如此,单个分组的差错就能引起GBN重传大量分组,然而很多分组没必要重传,随着差错率的增加,流水线可能会被这些不必要的重传分组所充斥,

​		而选择重传协议通过让发送发进重传哪些它换衣在接收方出错的的分组而避免了不必要的重传,这种个别,按需的重传要求接收方逐个的确认正确接收的分组,再次用窗口长度N来限制流水线中未完成未确认的分组数,然而与GBN不同的是,发送方已经手打了对窗口中某些分组的ACK.



### 面向连接的运输: TCP

​		学习了可靠运输的基本原理,而TCP是因特网运输层的面向连接的可靠的运输协议

#### TCP 连接

​		TCP 被称为是`面向连接的`这是因为在一个应用进程可以开始向另一个应用进程发送数据之前,两个进程必须先相互握手,即他们必须相互发送某些预备报文段,以建立确保数据传输的参数,作为TCP连接建立的一部分,连接的双方豆浆初始化TCP连接相关的许多TCP状态变量.

​		连接时一条逻辑连接,其共同状态仅保留在两个同心端系统的TCP程序中,由于TCP协议只在端系统中运行,而不在中间的网络元素(链路和交换机)中运行,所以中间元素不会维持TCP连接状态,事实上中间路由器对TCP连接完全视而不见,他们看到的是数据,而不是连接.

​		TCP连接时`全双工服务`:如果一台主机上的进程A与另一个主机上的进程B存在一条TCP连接,那么应用层数据就可以从进程B流向进程A的同事,也从进程A流向进程B,TCP连接也总是`点对点`的,即在单个发送方与单个接收方之间的连接,所谓`多播`,即在一次发送操作中,从一个发送方将数据传送给多个接收方,这种情况对TCP来说是不可能的,对于TCP而言是一对一的.

​		TCP是通过如下方式来建立连接的:

1. 客户首先发送一个特殊的TCP报文段,服务器用另一个特殊的TCP报文段来响应,最后客户在用第三个特殊报文段作为相应,前两宝报文段不承载`有效荷载`不包含应用层数据,而第三个报文段可以承载有效荷载,由于两个主机之间发送了三个报文段,所以这种连接过程被称为`三次握手`.
2. 通过`三次握手`建立了连接,客户通过套接字传递数据,数据一旦通过该门,它就由客户中运行的TCP控制了,TCP将这些数据引导到该连接的`发送缓存`里,发送缓存是发起三次握手期间设置的缓存之一,再接下来TCP会不时的从发送缓存中取出一块数据,并将数据传递到网络层.
3. TCP为每块客户数据配上一个TCP首部,从而形成多个`TCP报文段`这些报文段被下传给网络层,网络层将其分别封装在网络层IP数据报中,然后这些IP数据报被发送到网络中,当TCP在另一端接收到一个报文段后,该报文段的数据就被放入该TCP连接的接收缓存中,之后应用程序从此缓存中读取数据流.该连接的每一段都有各自的发送缓存和接收缓存



​		所以综上所述,TCP的连接组成包括:一台主机上的缓存,变量和御锦城连接的套接字,以及另一台主机上的另一组缓存,便令与进程连接的套接字



#### TCP报文段结构

​		TCP报文段由首部字段和一个数据字段组成,数据字段包含一块应用数据.

​		与UDP一样,首部包含了源端口号和目的地端口号,他被用于多路复用/分解来自或送到应用层的数据,另外还包含`检验和字段`,TCP报文首部还包含下列字段:

1. 32比特的`序号字段`和32比特的`确认号字段`这些字段被TCP发送方和接收方用来实现可靠数据传输服务
2. 16比特的`接收窗口字段`该字段用于流量控制,该字段用于指示接收方愿意接收的字节数量
3. 4比特的`首部长度字段`该字段知识了以32比特的字为单位的TCP首部长度,由于TCP选项字段的原因,TCP首部的长度是可以变的.
4. 可选与变长的`选项字段`,该字段用于发送方和接收方协商最大报文长度时,或在高速网络环境下用作窗口调节因子时使用个,首部字段中还顶一个了一个时间戳
5. 6比特的`标志字段`ACK比特用于指示去人字段中的的值是有效的,即改吧文已经被承购接受报文段的去人,RST,SYN和FIN比特用建立连接和拆除.在明确拥塞通告中使用了CWR和ECE比特,最后使用URG比特用来是指报文段里存在着被发送端的长层实体置为紧急的数据,金及数据的最后一个字节由16比特的金及数据指针字段指出,当金及数据存在并给出指向紧急数据指针的时候,TCP必须通知和接收端的上层实体.



​		序号和确认号,这两个字段是TCP报文首部最重要的字段,这两个字段是可靠传输服务的关键部分

​		TCP吧数据看成一个无结构的,有序的字节流,一个报文段的序号是该报文段首字节的字节流编号,举例来说假设主机A上的一个进程想通过一条TCP连接向主机B上的一个进程发送一个数据流,主机A中的TCP将隐式地对数据流中的每一个字节编号.

​		确认号比序号难处理一些,TCP是全双工的,因此主机A在向主机B发送数据的同时,也许叶鏊收到来自主机B的数据(都是同一条TCP连接的一部分),从主机B到达的每个报文段中都有一个序号用于从B流向A的数据,主机A填充进报文段的确认号是主机A期望从主机B收到的下一字节的序号.



#### TCP连接管理

​		客户中的TCP会用以下方式与服务器中的TCP建立一条TCP连接:

1. 第一步 客户端的TCP首先向服务器端的TCP发送一个特殊的TCP报文,该报文中不包含应用层数据,但是在报文段的首部中的一个标志位(即SYN比特)被置为1,因此,这个特殊报文段被称为SYN报文段,另外客户会随机的选择一个初始序号,并将此编号放置于该起始的TCP SYN报文段的序号字段中,该报文段会被封装在一个IP数据报中,并发给服务器,为了避免某些安全性攻击,在适当的随机化选择 client isn方面有着不少又去的研究
2. 第二步 一旦包含TCP SYN报文段的IP数据报达到服务器,服务器会从该数据报中提出TCP SYN 报文段,为该TCP连接分配TCP缓存和变量,并向该客户TCP发送允许连接的报文段,这个允许连接的报文段也不包含应用层数据,但是在报文段的首部却包含三个重要的信息,首先SYN比特被置为1,其次,该TCP报文段首部的确认号字段被置为 client isn + 1,最后,服务器选择自己的初始化序号,并将其放到TCP报文段首部的序号字段中,该允许连接的报文段被称为 SYNACK 报文段
3. 第三步 在收到SYNACK报文段后,客户也要给该连接分配缓存和变量,客户主机则向服务器发送另外一个报文段,最后一个报文段对服务器的允许连接的报文段进行了去人,因为连接已经建立了,所以该SYN比特被置为0,该三次握手的点个步骤可以在报文段负债中携带客户到服务器的数据



































































































































































.