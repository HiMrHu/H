---
title: 计算机网络
date: 2019-11-23 17:34:33
tags: 网络
---

计算机网络笔记 - 自顶向下的方法
<!-- more -->



# 计算机网络和因特网

## 网络核心

### 分组交换

​		一般而言，从源端系统向目的端发送一个报文, 源将长报文划分为较小的数据块, 称之为分组, 在源和目的地之间, 每个分组都通过通信链路和`分组交换机`传送. (交换机主要有两类: `路由器`和`链路层交换机`).  



> ​		分组以等于该链路`最大`传输速率的速度传输通过电信链路,因此如果某源端系统或分组交换机经过一条链路发送一个 L 比特的分组, 链路的传输速率为 R bit/s, 则传输该分组的时间为 L/R s.



### 排队延时和分组丢失

​		对于每条相连的链路,该分组交换机具有一个`输出缓存`(也称输出队列), 因此当该链路忙于传送其他分组, 该分组必须在输出缓存中`等待`. 因此除了转发延时, 分组还要承受数据缓存的`排队时延`, 时延是变化的, 主要取决网络拥堵的程度, 又因为缓存空间有限, 当缓存空间使用完毕, 将出`分组丢失`也就是`丢包` ,到达的分组或已经排队的分组之一将被丢弃.



### 转发表和路有选择协议

​		在因特网中,每个端系统具有一个被称为 IP 地址的地址, 当源主机箱目的端系统发送一个分组时, 源在该分组的首部包含了`目的地的 IP 地址`, 当一份到达网络中的路由器时, 路由器检查该分组的目的地的`一部分`并向一台相邻的路由器转发该地址, 每台路由器具有一个`转发表`,用于将目的地址(护着地址的一部分) 映射称为输出链路. 路由器会检查分组的地址, 并使用转发表将分组导向到适当的链路中.



### 电路交换

​		通过网络链路和交换机移动数据有两种基本方法: `电路交换`和`分组交换`.

​		在电路交换网络中,在端系统通信会话期间,`预留了`端系统间沿路径通信所需要的资源(缓存,链路传输速率), 而在分组交换网络中, 这些资源则`不是预留的`, 会话的报文按需使用这些资源, 其后果可能是不得不等待接入通信线路.



电路交换网络中的复用

​		链路中的电路通过`频分复用`(Frequency-Division Multilexing, FDM)或`时分复用`(Time-Division Multiplexing, TDM)来实现, 对于FDM, 链路的频谱由跨越链路创建的所有连接共享, 在连接器件链路为每条连接专用一个频段,例如在一条链路中电话通常是 4kHz, 而调频无线电通常为88 - 108kHZ的频谱, 其中每个电台被分配一个特定的频段.

​		而对于TDM链路,时间被分为固定期间的帧, 并且每个帧又被划分为固定数量的间隙,当网络跨越一条链路创建一条连接时, 网络在每个帧中为该链接制定一个间隙. 这些间隙专门由该链接单独使用, 一个时隙(在每个帧内)可以用于传输该链接的数据.

 



分组交换和电路交换的区别:

- 分组交换可能会有不可预测的延迟,而电路交换则是固定的
- 分组交换可以更高效的利用宽带,而且他比电路交换简单有效实现成本更低,而电路交换则更好相反



### 分组交换网中的时延,丢包和吞吐量

​		分组从一台主机(源)出发, 通过一系列路由器传输, 在另一台主机(目的地)中结束他的历程. 当分组从一个节点(主机或者路由器)沿着这条路径到达后续节点(主机或者路由器), 该分组在沿途的每个节点经受了几种不同类型的时延, 其中最重要的是以下集中时延:

- 节点处理时延

- 排队时延

- 传输时延

- 传播时延

  以上时延相加结果就是节点总时延



### 时延的类型

1. 处理时延

   ​		检查分组首部和决定该分组导向何处所需要的时间是`处理时延`的一部分. 高速路由器的处理时延通常是微秒或者更低的数量级.

2. 排队时延

   ​		在队列中,当分组在链路上传输时, 它经受`排队时延`, 分组的排队时延取决于链路中等待传输的分组数量,如果队列是空的则时延为0, 如果流量很大,则该队列会很长, 时延将会变长, 实际的排队时延可以是毫秒级到微秒级.

3. 传输时延

   ​		嘉定分组以先到先服务方式传输----这在分组交换机中是常见的额方式, 仅当所有已经到达的分组被传输后, 才能传输刚到达的分组. 例如对于一条 10Mbps 的以太网链路, 速率是R=10Mbps,`传输延时`是L/R, L是该分组的长度.实际的传输时延通常在毫秒到微秒量级

4. 传播时延

   ​		一旦一个 bit 被推向链路, 该比特需要向路由器 B 传播, 从该链路的起点到路由器 B 传播所需要的时间就是`传播时延`. 这取决于传播链路的物理媒介, 在广域网中, 传播时延通常为毫秒量级.

5. 传输时延和传播时延的比较

   ​		两者的差异是微秒而重要的, 传输时延是路由器推出分组所需要的时间, 他是分组长度和链路传输速率的函数,而与两台路由器之间的距离无关, 而传播时延是一个 bit 从一台路由器传播到另一台路由器所需要的时间,他是两个路由器之间距离的函数, 而与分组长度或链路传输速率无关.



### 协议分层

​		因特网的协议栈有五个层次组成: `物理层` `链路层` `网络层` `传输层` `应用层` 

#### 应用层

​		应用层是网络应用程序及他们的应用层协议存留的地方,因特网的应用层有很多协议,例如 HTTP SMTP FTP 等,还有域名系统 DNS.

​		应用层协议分布在多个端系统上,从一个段系统的应用程序使用协议与另一个端系统中的应用程序交换信息分组, 这种位于应用层信息分组称为报文.

#### 运输层

​		英特网的运输层在应用程序之间传送应用层报文, 在英特网中,有两种运输协议, 即 TCP 和 UDP ,  TCP 向它的应用层提供了面向连接的服务,这种服务包括了应用层报文向目的地的确保传递和流量控制, TCP 也将长报文分为短报文,并提供拥塞控制机制,因此当网络拥塞是,源一致其传输速率, 而 UDP 协议向他的应用程序提供无连接服务,这一种不提供不必要服务的服务, 没有可靠性, 没有流量控制,也没有拥塞控制.

#### 网络层

​		因特网的网络层负责将称为`数据报`的网络层从分组从一台主机移动到另一台主机,

#### 链路层

​		因特网的网络层通过源和目的地之间的一系列路由器路由数据报,为了将分组从一个节点(主机或路由器)移动到路径的下一个节点,网络层必须依靠该链路层的服务.特别是在每个节点,网络层将数据报下传给链路层,链路层沿着路径将数据报传给下一个节点,在该下一个节点,链路层将数据报上传给网络层.

#### 物理层

​		物理层的任务是将该帧中的一个个bit从一个节点移动到下一个节点.在这层中的协议仍然链路层相关的,并且进一步与该链路(传输介质)的实际参数媒体相关.



# 应用层

## 应用层协议原理

### 进程与计算机网络之间的接口

​		多数应用程序是由通信进程对组成,每对中的两个进程互相发送报文. 从一个进程向另一个进程发送的报文必须通过下面的网络, 进程通过一个称为`套接字`的软件接口向网络发送报文和从网络接受报文.

> 套接字是同一台主机内应用层与传输层之间的接口,由于该套接字是建立网络应用程序的可编程接口, 因此套接字(socket)也被称为应用程序和网络之间的`应用程序编程接口(Application Programma Interface, API)`.

​		应用程序开发者可以控制套接字在应用端的一切, 但是对于该套接字的运输层几乎没有控制权, 应用程序开发者对于运输层的控制仅限于:

1. 选择运输层协议
2. 也许能设定几个运输层参数,如最大缓存和最大报文段长度等



一旦应用程序开发者选择了一个运输层协议(如果可供选择的话),则应用程序就建立在由该协议提供的运输服务之上.

### 进程寻址

​		例如在想特定目的地发送向邮政邮件, 目的地需要有一个地址,类似的,在一台主机运行的进程向在另一台主机上运行的进程发送分组, 接受进程需要有一个地址,为了标识该接受进程,需要定义两个信息, 主机的地址以及在目的主机中指定接受进程的标识符.

​		而在因特网中,主机由其`IP地址`标识,一般而言发送进程还必须指定运行在接收主机上的接收进程,因为一般而言一台主机能够运行许多网络应用,而目的地的`端口号`则用于这个目的,已经给流行的应用分配了特定的端口号,例如 Web服务使用80来标识,邮件服务使用25标识.

###可用应用程序使用的运输服务

​		包括因特网在内的许多网络提供了不止一种运输协议,开发一个应用时必须选择一个可用的运输协议,对于不同的运输协议大体可以通过一下四种进行分类: `可靠数据传输` `吞吐量` `定时` 和 `安全性`

#### 可靠数据传输

​		分组在计算机中可能丢失,例如丢包,但是对于某些应用,例如银行系统,分组丢失会导致灾难性后果,因此为了支持这些应用,必须做一些工作由应用程序的一段发送的数据正确和完整的交付给该应用程序的另一端, 如果一个协议提供了这样的确保数据交付的服务,就认为提供了`可靠数据传输`,运输层协议能够潜在的向应用程序提供的一个重要服务是进程到进程的可靠数据传输. 当一个运输协议提供这种服务时,发送进程只需要将其数据传递进套接字,就可以完全相信该数据将能无差错地到达接受进程.

​		当一个运输层协议不提供可靠数据传输时, 由发送进程发送的某些数据可能达到不了接收进程,这可能能被`容忍丢失的应用`所接受,如视频,音频应用中丢失部分数据会出现小干扰,而不是致命的损伤

#### 吞吐量

​		可用吞吐量就是发送进程能够像接收进程交付bit的速率,因为其他会话将功效沿着该网络路径的宽带,并且因为该到达和离开,该可用吞吐量会随时间波动,具有吞吐量要求的应用程序被成为`宽带敏感的应用`,宽带明爱的应用具有特定的吞吐量要求, 而`弹性应用`能够根据当时可用的宽带或多或少的利用可用使用的吞吐量, 例如电子邮件,文件传输,Web传送都属于弹性应用.

#### 定时

​		运输层协议也能提供定时保证,如同具有吞吐量那样的保证,例如保证发送方注入套接字中的bit不迟于100ms到达接收方.

#### 安全性

​		运输协议能够为应用程序提供一种或者多种安全性服务,例如在发送主机中,运输协议能够加密发送进程传输中的所有数据,在接收主机中,运输协议能够在将书记交付给接收进程之前解密这些数据.



### 因特网提供的运输服务

​		因特网(更一般的是TCP/IP网络)为应用程序提供了两个运输协议,即 UDP 和 TCP, 所以当为英特网提供一个新的应用程序时,首先要考虑的决定是: 使用 UDP 还是 TCP , 每个协议为调用他们的应用程序提供了不同的服务集合



#### TCP

​		TCP 服务模型包括面向连接服务和可靠数据传输服务, 当某个程序调用TCP作为其运输协议时, 该应用程序就能获得来自TCP的这种服务.

1. 面向连接的服务

​		在应用层数据报文开始流动之前, TCP 让客户和服务器互相交换运输层控制信息, 这个所谓的握手过程是提醒客户和服务器,让他们为大量分组的到来做好准备, 在握手阶段后,一个 TCP 连接就在两个进程的套接字之间建立,这条连接时双工的,即连接的双发的进程可以在此连接上同事进行报文手法,当应用程序结束报文发送时,必须拆除该连接.

2. 可靠的数据传送服务

   通信能够依靠TCP,无差错并且按照适当的顺序交付所发送的数据,当应用程序的一段将字节流传进套接字时,它

能够依靠 TCP 将相同的字节流交付给接收方的套接字,而没有字节的丢失和冗余.

​		TCP 协议还具有拥塞控制机制,这种服务并不一定能为通信进程带来直接的好处,但能为因特尔网络带来整体的好处,当发送放和接收方网络出现拥塞时, TCP 的拥塞控制会一致发送进程. TCP 拥塞控制也试图限制每个 TCP 连接,使他们达到公平共享网络宽带的目的.



#### UDP

​		UDP 是一种不提供不必要服务的轻量级运输协议, 它仅提供最小服务, UDP 是无连接的, 因此在两个进程通信前是没有握手过程的, UDP协议提供一种不可靠数据传送服务, 当进程讲一个报文发送进 UDP 套接字时, UDP 协议并不保证该报文将到达接收进程,而且到达接收进程的报文也可能是乱序到达的.



### 应用层协议

​		`应用层协议`定义了运行在不同端系统上的应用程序进程如何相互传递报文. 特别是应用层协议定义了:

1. 交换的报文类型,比如请求报文和响应报文
2. 各种报文类型的语法, 如报文中的各个字段以及这些字段是如何描述的
3. 字段的语义,即这些字段中的信息的含义
4. 确定一个进程何时如何发送报文,对报文进行响应的规则

​		Web的应用层协议时HTTP, 它定义了浏览器和Web服务器之间传输的报文格式和序列,因此, HTTP只是Web的一个部分,尽管是一个重要的部分,又例如邮件系统的应用层协议就是SMTP(简单邮件传输协议),因此邮件的首要应用层协议SMTP也只是电子邮件应用的一个部分.



###  Web 和 HTTP

 #### HTTP 概况

​		Web 的应用层协议是`超文本传输协议`(HyperText Transfer Protocol, HTTP),  它是 Web 的核心, HTTP 由两个程序实现: 一个客户程序和一个服务器程序. 客户程序和服务程序运行在不同的端系统中,通过交换HTTP报文进行会话,HTTP 定义了这些报文的结构以及客户和服务器进行报文交换的地方. 客户想他的套接字接口发送和接收HTTP报文,一旦客户向他的套接字接口发送了一个请求报文,这个报文就脱离了客户端控制并且进入TCP控制, 而TCP为HTTP提供可靠的数据传输服务.



#### 非持续连接和持续连接

​		在许多因特网应用程序中,客户和服务器在一个想当长的时间范围内通信,其中客户发出一系列请求并且服务器对每个请求进行相应,客户-服务器交互式通过TCP进行的,那么程序的研制者就要做出一个重要的决定,即每个请求/响应式经单独的TCP进行还是所有的请求和响应通过相同的TCP连接发送,采用前一种方法,该应用程序被称为使用`非持续连接`采用后一种方法,该应用程序被称为使用`持续连接`



#### 采用非持续连接的HTTP

​		当采用非持续连接情况下,服务器向客户端发送一个 Web页面的步骤:

1. HTTP客户进程在80端口发起一个到服务器的TCP连接
2. HTTP 客户经他的套接字向该服务器发送一个HTTP请求报文,报文中包含了所需要的资源
3. HTTP 服务器进程经他的套接字接收到该请求报文,并在一个HTTP响应报文中封装对象,并通过其套接字向客户发送响应报文
4. HTTP服务器进程通知TCP断开该TCP连接(但是直到TCP确认客户已经完整的收到响应报文,它才会实际中段连接)
5. HTTP客户收到响应报文, TCP 连接关闭, 并解析报文,从中读取资源或者资源地址,对于地址重复以上步骤得到资源.



​		上面步骤说明了非持续连接的使用,其中每个TCP连接在服务器发送一个对象后关闭,该链接并不为其他的对象而持续下来.

​		浏览器和Web服务器之间发起一个TCP连接,涉及一次"三次握手"过程,即客户想服务器发送一个小TCP报文,服务器用一个小的TCP报文做出确认响应,最后客户想服务器返回确认, 三次握手中前两部分所消耗的时间占用一个`往返时间`,完成三次握手的前两部分后,客户结合三次握手的第三部分(确认)向该TCP链接发送一个HTTP请求报文,一旦该请求报文送达服务器,服务器就在该TCP连接上发送响应,该HTTP请求/响应用去了另一个`往返时间`因此粗略讲总的响应时间就是两个`往返时间`加上服务器传输HTML文件的时间.



#### 采用持续的HTTP

​		非持续连接的缺点:

1. 必须为*每一个请求的对象*建立和维护一个全新的连接,对于每个这样的连接,在客户和服务中都要分配TCP的缓冲区和保持TCP变量,这给服务器带来了严重的负担.
2. 每一个对象需要经受双倍的`往返时间`即一个用于创建TCP的往返时间,一个用户请求和接收一个对象的往返时间

在采用HTTP1.1持续连接的情况下服务器在发送响应后保持该TCP连接打开,在相同的客户与服务器之间,后续的请求和报文能够通过相同的连接进行传输, 这样可以节省资源和加快响应时间.一般来说一条连接经过一定时间间隔(可配置的间隔)仍未被使用, HTTP 服务器就关闭该连接,HTTP的默认模式是使用带流水线的持续连接, HTTP/2是子HTTP1.1基础上构建的,他允许在相同的连接中多个请求和回答交错,并增加了该连接中优化HTTP报文请求和回答机制.



#### HTTP报文格式

​		HTTP规范包含对HTTP格式的定义,HTTP报文有两种:`请求报文`和`响应报文`

		>```html
		>// 请求报文
		>GET / HTTP/1.1
		>Host: developer.mozilla.org
		>Accept-Language: fr
		>```

​		报文使用普通的ASCII文本, 又若干行组成,每一行由一个回车和换行符结束,最后一行在附加一个回车换行符.

HTTP请求报文的第一行叫做`请求行`后继的行叫做`首部行`请求航有三个字段:`方法字段` `URL` 和 `HTTP版本`字段

> ```html
> // 响应报文
> HTTP/1.1 200 OK
> Date: Sat, 09 Oct 2010 14:28:02 GMT
> Server: Apache
> Last-Modified: Tue, 01 Dec 2009 20:18:22 GMT
> ETag: "51142bc1-7449-479b075b2891b"
> Accept-Ranges: bytes
> Content-Length: 29769
> Content-Type: text/html
> 
> <!DOCTYPE html... (here comes the 29769 bytes of the requested web page)
> ```

​		想一个报文包含三个部分: 一个初始`状态行`, 若干`首部行`然后是`实体体`



#### cookie

​		HTTP 是无状态的,这简化了服务器的设计,HTTP中使用了cookie,来对用户进行追踪,识别以及限制.



​		



