---
title: HTTP
date: 2018-8-17 19:49:44
tags: HTTP
---

学习一下网络世界的基础HTTP

<!-- more -->

# HTTP 概述

## web的结构组件

- 代理
  位于客户端和服务器之间的HTTP中间实体

- 缓存
  HTTP 的仓库,常使用页面的副本可以保存在距离客户端更近的地方

- 网关
  连接其他应用程序的特殊web服务器

- 隧道
  对HTTP通信报文进行盲转发的特殊代理

- Agent代理
  自动发起HTTP请求的半智能Web客户端


### 代理

代理比较好理解,就是位于客户端和服务端之间,接收所有客户端的HTTP请求,并将这些请求转发给服务器(也有可能会对请求尽心修改后转发),客户端无法感知代理的存在.

### 缓存

Web缓存或者代理缓存,是一种特殊的HTTP代理服务器,可以将经过代理传送的常用文档复制保存起来(保存在距离客户端比较近的地方),这会客户端直接从比较远服务端传输快得多

### 网关

网关是一种特殊的服务器,它作为其他服务器的中间实体使用,通常用于将HTTP流量转化为其他的协议,同样客户端不可感知网关.

### 隧道

隧道是建立起来之后就会在两条连接之间对原始数据进行盲转发的HTTP应用程序,HTTP隧道通常用在一条或者多条HTTP连接上转发非HTTP数据,转发时不会窥探数据

### Agent代理

用户 Agent 代理,是代表用户发起HTTP请求的客户端程序,所有发布Web请求的应用程序都是HTTP Agent代理


# URL与资源

URL 就是因特网资源的标准化名称,URL指向一条点子信息片段,告诉你他们位于何处,以及如何进行交互

## 方案的世界

| 方案       | 描述                                                                                                                        |
| ---------- | --------------------------------------------------------------------------------------------------------------------------- |
| HTTP       | 超文本传输协议方案,除了没有用户名和密码之外与通用的URL格式相符,如果省略端口号那么默认就为80端口                             |
| HTTPS      | 方案HTTPS 与方案HTTP是一堆,唯一区别是位于方案HTTPS使用了SSL,SSL为HTTP提供了端到端的加密价值,其语语法与HTTP相同默认端口为443 |
| mailto     | Matilto URL指向的是email地址                                                                                                |
| ftp        | 文件传输协议URL,可以用来从FTP服务器上下载或者上载文件                                                                       |
| rtsp,rtspu | RTSP URL是可以通过实时流传输协议解析音频视频的标识符                                                                        |
| file       | 方案file表示指定主机(通过本地磁盘网络文件系统或者其他)上可以直接访问文件                                                    |
| news       | 方案news用来访问一些特定的文章或者新闻组,他有一个特殊的性质:newsURL自身包含的信息不足以对资源进行定位                       |
| telnet     | 方案telnet用于交互式访问业务,他表示的并不是对象本身,而是可以通过telnet协议访问的交互应用程序                                |


# HTTP报文

讲解了以下概念:

- 报文是如何流动的
- HTTP报文的组成部分(起始行,首部和实体的主体部分)
- 请求和响应报文之间的区别
- 请求报文支持的各种功能(方法)
- 和响应报文一起返回的各种状态码
- 各种各样的HTTP头部都是用来做什么的

## 报文流

HTTP报文是在HTTP应用程序之间发送的数据块,这些数据块以文本形式的元信息开头,这些信息描述了报文的内容以及含义,后面跟着可选的数据部分,这些报文在客户端,服务器和代理之间流动,术语:`流入`,`流出`,`上游`,`下游`都是用来描述报文的方向

### 报文流入源端服务器

HTTP 使用术语`流入`和`流出`来描述事物处理的方向,报文流入源端服务器,工作完成之后,会流回用户的Agrnt代理中

### 报文的组成部分

HTTP报文是简单的格式化数据块,每条报文都包含来自客户端的请求,或者来自服务端的相应,它们由三个部分组成:对报文进行描述的起始行,包含属性的头部块,以及可选的包含数据的主题部分.

### 报文的语法

所有的HTTP报文都可以分为两类: `请求报文`和`相应报文`,请求报文会向Web服务器请求一个动作,相应报文将请求的结果返回给客户端,两者的结构基本相同(起始行,请求头/相应头和可选的包含数据的主题部分)

下面是报文的格式

```html
<!-- 请求报文 -->
<method> <request-URL> <version>
<headers>
<entity-body>

```

```html
<!-- 相应报文 -->
<version><status><reason-phrase>
<headers>
<entity-body>
```

两者只有起始行的语法不太相同

- 方法
  客户端希望服务器对资源执行的动作,是一个单独的动词,比如GET/HEAD或者POST

- 请求URL(request-URL)
  命名了所请求资源,或者URL路径的完整URL,如果直接与服务器进行对话,只需要URL的路径组件是绝对路径

- 版本
  报文所使用的HTTP版本

- 状态码(status-code)
  三位数字描述了请求过程中所发生的情况,每个状态码的第一位都用于描述一般的类别(成功或者出错)

- 原因短语(reason-phrase)
  数字状态码的可读版本,包含了终止序列之前的所有文本,原因短语只对人类有意义,对程序而言并不会起作用

- 头部(header)
  可以有零个或者多个头部,每个首部都包含了一个名字,后面跟着一个冒号,然后是一个可选的空格接着是一个值,最后是一个CRLF(换行符),首部是由一个空行(CRLF)结束的

- 实体的主体部分(entity-body)
  实体的主体部分包含一个由任意数据组成的数据块,这个是可选的


### 起始行

所有的HTTP报文都是以一个起始行作为开始的,请求报文的起始行说明了`要做什么`,相应报文的起始行说明`发生了什么`.

1. 请求行
请求报文请求服务器对资源进行一些操作,请求报文的起始行,包括了一个方法和一个URL,这个方法描述了服务器应该执行的操作,请求URL描述了要对那个资源执行这个方法,请求行中还包含了HTTP的版本,来告诉服务器使用的是那种HTTP.

2. 响应行
相应报文承载了状态信息和操作产生的结果数据,将其返回给客户端,相应报文的起始行,包含了相应报文使用的HTTP版本,数字状态码,以及描述操作状态的文本形式的原因短语

3. 方法
请求的起始行以方法作为开始,方法用来告知服务器要做些什么

**常用的HTTP方法**

| 方法    | 描述                                           | 是否包含主体 |
| ------- | ---------------------------------------------- | ------------ |
| GET     | 从服务器获取一份文档                           | 否           |
| HEAD    | 只从服务器获取文档的首部                       | 否           |
| POST    | 向服务器发送需要处理的数据                     | 是           |
| PUT     | 将请求的主体部分储存在服务器上                 | 是           |
| TRACE   | 对可能经过代理服务器传送到服务器的报文进行追踪 | 否           |
| OPTIONS | 决定可以在服务器上执行那些方法                 | 否           |
| DELETE  | 从服务器上删除一份文档                         | 否           |



### 状态码

方法是客户端告诉服务器做什么事,而状态码则告诉客户端,发生了什么事

状态码是在每条相应报文的起始行中返回的,会返回一个数字状态和一个可读的状态码,数字码便于对程序惊醒差错处理,而原因短语则更便于人们理解

可以通过三位数字码对不同状态码进行分类,200-299之间的状态码表示成功,300-399之间的状态码表示资源已经被移走,400-499之间的状态码表示客户端请求出错了,500-599之间的状态码则表示服务器出错了

**状态码分类**

| 整体范围 | 已定义范围 | 分类       |
| -------- | ---------- | ---------- |
| 100-199  | 100-101    | 信息提示   |
| 200-299  | 200-206    | 成功       |
| 300-399  | 300-305    | 重定向     |
| 400-499  | 400-415    | 客户端错误 |
| 500-599  | 500-505    | 服务端错误 |

### 原因短语

原因短语是相应起始行中最后一个组件,它为状态码提供了文本形式的解释

原因短语和状态码是成对出现的,烟瘾短语是状态码的可读版本,应用程序开发者将其传递给用户,用于说明在请求期间发生了什么情况

HTTP 规范并没有提供任何硬性规定,要求原因短语以何种形式出现


### 版本号

版本号会以HTTP/x.y的形式出现在请求和响应的报文起始行中,为HTTP应用程序提供一种将自己所遵循的协议版本号告知对方的方式

使用版本号的目的是为了使用HTTP的应用程序提供一种线索,以便互相了解对方的能力和报文格式.

版本号说明了应用程序支持的最高HTTP版本,但在HTTP1.0应用程序在解析包含HTTP1.1的响应时会认为这个相应时1.1相应,而实际上只是相应应用程序所使用的协议等级,在这些情况下,版本号会在应用程序之间造成误解

### 头部

HTTP头部字段向请求和响应添加了一些附加消息,本质上来说,它们只是一些名/值对的列表

1. 首部分类

HTTP规范定义了集中首部字段,应用程序也可以随意发明自己所使用的首部,HTTP的首部可以分为一下几类

- 通用首部
  既可以出现在请求报文中,也可以出现在相应报文中

- 请求首部
  提供更多关于请求的信息

- 相应首部
  提供更多关于相应的信息

- 实体头部
  描述主题的长度和内容,或者资源自身

- 扩展首部
  规范中没有定义的新首部

每个首部都有一个简单的语法: `名字后面跟着冒号:然后跟上可选的空格,再跟上字段值,最后是一个CRLF`

** 常见的首部实例**

| 首部实例                              | 描述                                    |
| ------------------------------------- | --------------------------------------- |
| Date: Tue,30ct 1997 02:15:03 GMT      | 服务器产生响应的日期                    |
| Content-length:15040                  | 实体的主题部分包含了15040字节的数据     |
| Content-type:image/gif                | 实体的主题部分是一个GIF图片             |
| Accept:image/gif,image/jpeg,text/html | 客户端可以接收GIF图片和JEPG图片以及HTML |

### 首部延续行

将长的首部行分为多行可以提高可读性,多出来的每行前面至少要有一个空格或者制表符