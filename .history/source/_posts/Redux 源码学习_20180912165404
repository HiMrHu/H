---
title: Redux 源码学习
date: 2018-09-11 15:12:29
tags: Redux
---

学习 Redux 源码

<!-- more -->

# 前置条件

注解[Redux源码](https://github.com/HiMrHu/Redux)

# Redux

根据[Redux提供的TodoList](https://github.com/reduxjs/redux/tree/master/examples/counter),思路是根据使用,反向的带入源码进行学习
这个例子中只使用了 `createStore` `dispatch` `getState`

## store

```jsx
import React from 'react'
import ReactDOM from 'react-dom'
import { createStore } from 'redux'
import Counter from './components/Counter'
import counter from './reducers'

const store = createStore(counter)
const rootEl = document.getElementById('root')

const render = () => ReactDOM.render(
  <Counter
    value={store.getState()}
    onIncrement={() => store.dispatch({ type: 'INCREMENT' })}
    onDecrement={() => store.dispatch({ type: 'DECREMENT' })}
  />,
  rootEl
)

render()
store.subscribe(render)
```

在上面的例子里, counter export default 一个函数, 即 reducer 函数, 这个函数作为参数传递给 createStore 生成 store


### createStore


redux 的[入口文件](https://github.com/HiMrHu/Redux/blob/master/Redux/index.js),判断当前运行代码是是否为开发版本代码,以及引入并导出了所有的模块


[createStore注释版本源码](https://github.com/HiMrHu/Redux/blob/master/Redux/createStore.js)

createStore 函数接受 reducer 作为参数, 并且最终返回一个对象:

```javascript
 {
    dispatch,
    subscribe,
    getState,
    replaceReducer,
    [$$observable]: observable

  };
```

createStore 最终返回的是上面那样一个对象,有几种方法,并且内部储存了 Reducer 的返回值作为整个状态树的 state

```jsx
const store = createStore(counter)

// store 的值变成了

{
    dispatch,
    subscribe,
    getState,
    replaceReducer,
    [$$observable]: observable

  }
```


接下来是调用dispatch


```jsx

const render = () => ReactDOM.render(
  <Counter
    value={store.getState()}
    onIncrement={() => store.dispatch({ type: 'INCREMENT' })}
    onDecrement={() => store.dispatch({ type: 'DECREMENT' })}
  />,
  rootEl
)

// 拿到了store 对象之后就可以调用 dispatch 方法来触发所有订阅更新
```

#### dispatch

```javascript

    function dispatch(action) {
    /** 判断action是不是一个普通对象 */
    if (!isPlainObject(action)) {
      throw new Error(
        "Actions must be plain objects. " +
          "Use custom middleware for async actions."
      );
    }

    /** 判断action是否存在 type 属性 */
    if (typeof action.type === "undefined") {
      throw new Error(
        'Actions may not have an undefined "type" property. ' +
          "Have you misspelled a constant?"
      );
    }

    /** 判断是否在 dispatch 中 */
    if (isDispatching) {
      throw new Error("Reducers may not dispatch actions.");
    }

    try {
      isDispatching = true;
      /** 调用 reducer 函数并且将当前state和action传过去 */
      currentState = currentReducer(currentState, action);
    } finally {
      isDispatching = false;
    }

    /** 一串赋值, 首先将 nextListenrs 赋值给 currentListeners */
    const listeners = (currentListeners = nextListeners);
    for (let i = 0; i < listeners.length; i++) {
      /** 逐个运行订阅函数进行发布 */
      const listener = listeners[i];
      listener();
    }
    /** 返回 action  */
    return action;
  }
```






dispatch 的源码就做了三件事

- 判断action是否合法(必须是一个普通的包含type属性的对象)

- 调用 reducer 函数并且传入 state 和 action 作为参数,并将 reducer 的返回值作为新的 state

- 最后逐个调用函数发布更新通知(订阅发布模式),并将 action 返回



dispatch 是发布,那么必然有一个订阅函数,用来订阅事件


#### subscribe

```jsx

const render = () => ReactDOM.render(
  <Counter
    value={store.getState()}
    onIncrement={() => store.dispatch({ type: 'INCREMENT' })}
    onDecrement={() => store.dispatch({ type: 'DECREMENT' })}
  />,
  rootEl
)

render()
store.subscribe(render)

```


上面的代码调用 store.subscribe 并将 render 函数作为参数传递

那么 subscribe 函数的源代码为


```javascript
function subscribe(listener) {
    if (typeof listener !== "function") {
      throw new Error("Expected the listener to be a function.");
    }

    if (isDispatching) {
      throw new Error(
        "You may not call store.subscribe() while the reducer is executing. " +
          "If you would like to be notified after the store has been updated, subscribe from a " +
          "component and invoke store.getState() in the callback to access the latest state. " +
          "See https://redux.js.org/api-reference/store#subscribe(listener) for more details."
      );
    }

    let isSubscribed = true;

    ensureCanMutateNextListeners(); // 使监听器数组发生变化生成一个新的数组
    nextListeners.push(listener); // 之后 push 一个监听器

    return function unsubscribe() {
      // 之后返回一个函数用于卸载/取消监听器
      if (!isSubscribed) {
        return;
      }

      if (isDispatching) {
        throw new Error(
          "You may not unsubscribe from a store listener while the reducer is executing. " +
            "See https://redux.js.org/api-reference/store#subscribe(listener) for more details."
        );
      }

      isSubscribed = false;

      ensureCanMutateNextListeners();
      const index = nextListeners.indexOf(listener);
      nextListeners.splice(index, 1);
    };
  }

```

通过分析源码可以看出 subscribe 函数 接受一个函数作为参数,之后通过构造一个通知事件列表,并将事件push订阅数组内
最后 subscribe 函数返回一个函数用于取消订阅

#### getState

```jsx

const render = () => ReactDOM.render(
  <Counter
    value={store.getState()}
    onIncrement={() => store.dispatch({ type: 'INCREMENT' })}
    onDecrement={() => store.dispatch({ type: 'DECREMENT' })}
  />,
  rootEl
)

```

getState 方法的作用就非常简单了,直接返回当前的状态树,源码也非常简单.

```javascript

  function getState() {
    if (isDispatching) {
      throw new Error(
        "You may not call store.getState() while the reducer is executing. " +
          "The reducer has already received the state as an argument. " +
          "Pass it down from the top reducer instead of reading it from the store."
      );
    }

    return currentState;
  }

```

判断当前是否正在处理dispatch,如果是的话抛出错误,如果不是返回当前 state 树



# 学习 React-Redux 和 Redux 的其他源码

Redux 官网提供了一个和 React 更好配合使用的例子,例子中使用了 React-redux 这个辅助库来帮助在 React 中使用 Redux

[React-Redux-TODO-LIST](https://github.com/reduxjs/redux/blob/master/examples/todos/src/index.js)


首先为了在 React 中更简单的使用 Redux , 所以 Redux 官方提供了一个 React-Redux 库,可以在 React 中高效和灵活的使用


React-Redux 库为我们提供了一个组件和一个函数

```jsx
import { Provider, connect } from 'react-redux'
```

## Provider

[带注释源码](https://github.com/HiMrHu/Redux/blob/master/React-Redux/components/Provider.js)

源码也比较简单

主要就是一个高阶组件内部使用了, `context` 这个 API (旧版), 对下属所有子组件进行通信

<Provider> 组价接受一个 store 作为属性,这个属性在内部会被赋值为组件属性, 并且设置了 childContextTypes和getChildContext

React 会向下自动传递参数,任何组件只要在它的子组件中,就能通过定义 contextType 来获取参数


## connect

这个组件比较复杂, 主要承担了几种职责:

- 判断传入参数是否合法
- 通过一个高阶组件,内部通过context 订阅 store 并且判断是否发生变化来决定组件是否进行重新渲染

其他的写的比较绕,看起来不容易理解,仅仅理解了一个大概
